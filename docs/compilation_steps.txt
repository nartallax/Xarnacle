Compilation steps

At compile time, the compiler is aware of all the used Sources (through some config file). These Sources are:
* code files (from these files target file (executable) is created)
* dynamic library files that have been compiled from the language (as long as they include information about their contents, they do not need headers) - linked dynamically at startup
* headers files + code: just as regular code files, only need to express package explicitly
* header files + dynamic libraries (just for compatibility with most of C libraries) - linked dynamically at startup; need explicit package

TODO: think about how exactly additional information is included inside DLLs and SOs

To generalize, Source is something that can provide a Symbol. Symbol is function, class or something similar. Symbol consists of:
* package name: name of package it originates from
* own name - it's personal name inside the package; 
* FQ name = package name + own name
* signature:
	* for Class/Trait/Struct:
		* list of methods and members with their signatures
		* inheritance list (non-recursive)
		* flags: accessibility (outside of the unit where the class/trait is defined), no_reflection flag (inheritance becomes impossible; no reflection pointer is included in class structure, no definition of this class is loaded to reflexive map at runtime), volatile
	* for Method:
		* flags: accessibility (protected/private/public (default)), override flag, final flag
		* overloads: list of Function signatures
	* for Member:
		* flags: accessibility (no overrides for Members)
		* implicit flags: is_static_linkable
		* underlying Variable signature
	* for Function:
		* list of arguments (Variable signatures)
		* return Type
		* flags: pure, tailcall, inline, synchronized
		* implicit flags: is_pure, is_tailcall_optimizeable, is_inlineable
	* for Variable:
		* its Type
		* its default value, if present
		* flags: mutability, volatility
		TODO: think about inferred volatility, or warning, or at least compiler flag that will turn all variables volatile (just for debug)

Symbols are divided into packages; for Sources that does not explicitly state their root package (for example, header files), pseudopackage is used (through mentioning package name in config file)

Compilation is incremental. That is, only one source code file at time is compiled (not generally true, as long as some steps could be paralleled from inside); only source code files that needs recompilation are recompiled.
To achieve this (and also make compilation faster), a lot of side-information is stored for each source file:
* AST (in JSON or similar easy-readable parsed format)
* flat AST (AST with syntax sugar resolved, types inferred and so on)
* symbol_names_used, symbols_used - list of FQ symbol names
* symbol_names_provided, symbols_provided - list of FQ symbol names
* requirements - Sources that provide symbols used
* beneficiars - Sources (most of the time not generic sources, but only source code files) that depends on this code file
* translated code (C code)
* object files (that are generated by compiler from translated code)

At start of compilation, compiler have:
	* project, that consists of
		* project definition file, where all the project settings are stored and from where all Sources are references
		* source code files
		* other (external) Source files that are not source code on our language.
	* some disk-stored cache from previous compilation that describes possibly outdated state of Sources

Each compilation is atomic. No two simultaneous compilation processes are allowed (for one project at least, otherwise it will be huge mess due to a lot of disk-stored cache).
So there are following compilation steps:

* external_update: updated external Sources are found, symbols_provided file are generated (updated) for them; symbols_provided for nonexistent Sources are deleted; list of updated external Sources is saved.

* parse:
	* seek (par): files with outdated or absent AST are searched; also deleted files are searched (that are AST files that have no corresponding source code file)
	* parse (par): these files are parsed, their ASTs are builded and written to file
		* tokenize: source code is split into small parts, named tokens
		* aggregate: tokens are assembled into lexems that represent language constructions. at the end of this step there is only one lexem that is AST
		* flush: AST is written on disk
	* extract (par): from parsed AST used and provided Symbol names are extracted and written into corresponding files.

* wireup:
	* mark (par): files that are needed to be recompiled are searched. These files are ones found on altered_code_seek and all of the beneficiars and former beneficiars. List of former beneficiars is extracted from beneficiars file (as long as it wasn't altered yet and contains obsolete information); list of actual beneficiars is extracted from consuments file. Also beneficiars of updated external Source files are found and included to recompilation list. No files other than files from this list are recompiled.
	* net (par): requirements and beneficiars files are updated by the information gathered from symbol names files. Obvious enough, beneficiars list is formed from former beneficiar list and files that was altered since last compilation (not without a filtering though)
	* reorder: tree is builded using dependency information for files that need to be recompiled. this tree is passed to next step.
	
* gather:
	* typelink (par): this step includes type inference and linkage. After this step, symbols_used and symbols_provided files are updated. Some of the files can be typelinked simultaneously (as long as they have all requisitions typelinked)
		Typelink step is not single; it is repeated sequence of steps.
		* types are inferred wherever possible
		* using these types, Symbols are linked more precisely than just names: particular overloads of methods are found.
		* if there no more empty type fields or non-linked Sources, step succeedes
		* if no references was resolved or types inferred on last iteration, step failes
		* otherwise typelink step is repeated from start.
	* transform: alter AST somehow (TODO: rethink order of this steps; allow user to alter it)
		* all_volatile: enabled by switch; mark EVERYTHING as volatile
		* link_determine: linkage type is determined for each function call
		* custom: any user-defined handlers are executed at this point (by default)
	* flatten (par): syntax sugar is removed from the source file; file AST becomes flat definition of methods and/or classes. Also inlining happens at the point. see Flattening steps for details.
		* inline: functions that are marked for inlining are inlined, or error is generated; also some more simple statically-linked functions are inlined
		* closure_inline: closures are inlined with calling function wherever possible (think about foreach(t => void) inlining to get the idea); no inlining is performed after some complexity limit of calling function (TODO: think about it some more; "public"	)
		(?) * closure_pure_sublimate: remaining closures that are pure functions became anonymous functions declared inside scope used
		* closure_impure_sublimate: remaining closures became anonymous classes declared inside scope used
		* unnest_class: classes declared inside other classes/functions are moved out to file-global scope
		(?) * unnest_function: functions declared inside other classes/functions are moved out to file-global scope
		* tailcall: functions that are marked as tail-recursive are restructured into loop, or error is generated; also some more recursive functions are restructured
		* simplify: various simplification of source code (constant expressions are pre-counted; pure exressions inside loops are factored out etc)
		* flush: resulting AST is flushed into flat AST file.
		
* check: various additional warnings and errors are emitted at this point.
	* errors
		* ???
	* warnings
		* unreachable code
		* IFs with constant condition
		* unused variables, private class fields and methods
		* useless mutability (mutable local variables or private fields that have exactly one value set at definition time)
		* useless pure function calls
		* unused result of function call (?)
		* ???
	
* compile:
	* generate (par): each of the files in the tree is translated to C code.
		* ???
	* objectize (par): each of translated code files are run through some C compiler (expected GCC, but not totally bound to it); object files are produced as output for each file.
	* link: all of object files (not only generated on steps before; all the object files for the project) are linked (by underlying compiler) into some executable, depending on target type.