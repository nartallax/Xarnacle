var Type = require(__dirname + require('path').sep + 'type.js');

var units = {};

// function value to code translation rules:
// if function variable declared in global namespace and is immutable: it becomes function declaration
// if function variable declared in class namespace (?) and is immutable: same, but name is mangled (to something like 'method_of_MyClass_with_name_myMethod')
// if function variable is declared inside function body and is immutable: same, but name is mangled even worse with parent function name
// if function value is assigned to mutable variable: name is autogenerated, function is created in global namespace
// ...any other cases?

// some lexical unit
var Unit = function(){
	// approximate coordinates of unit in source code
	// NOT guaranteed to be accurate or even filled
	// use only to roughly point programmer to error site
	this.lineNumber = null;
	this.columnNumber = null;
	this.filename = null;
	
	this.parent = null;
}

Unit.define = (name, constr, obj, base) => {
	constr = constr || function(){};
	obj = obj || {};
	base = base || Unit;

	constr.prototype = new base();
	
	Object.keys(obj).forEach(key => constr.prototype[key] = obj[key])
	
	constr.prototype.getName = () => name;
	
	// trick to ensure good value in ident param
	var transCode = constr.prototype.toTranslatedCode;
	constr.prototype.toTranslatedCode = function(ident, prefix, postfix){
		return this.isEmpty()? '': (prefix || '') + transCode.call(this, ident || '') + (postfix || '');
	};
	
	if(name in units)
		throw 'Duplicate definition of lexical unit "' + name + '"';
	
	units[name] = constr;
	
	return constr;
}

Unit.prototype = {
	getName: function(){ return '' },
	getChildren: function(){ return this.children || (this.children = []) },
	getLastChild: function(){ return this.children? this.children[this.children.length - 1]: null },
	childCount: function(){ return this.children? this.children.length: 0 },
	haveChildren: function(){ return this.children? this.children.length > 0: false },
	eachChild: function(cb){ return this.haveChildren()? this.children.map(cb): [] },
	
	addChild: function(child){
		this.getChildren().push(child)
		child.parent = this;
	},
	
	extractChildrenBy: function(critter, resultArray){
		resultArray = resultArray || [];
		this.eachChild(c => {
			critter(c) && resultArray.push(c);
			c.extractChildrenBy(critter, resultArray);
		});
		return resultArray;
	},
	
	simplifyChildren: function(){ this.eachChild(c => c.simplify()) },
	inferChildTypes: function(){ this.eachChild(c => c.inferTypes()) },
	
	toString: function(){ return this.toTokenString() },

	// top-level unit could be really top or be a part of top-level sequence
	// in both cases it is considered to be top-level unit
	isTopLevel: function(){
		return this.parent === null || ((this.parent instanceof units.sequence) && this.parent.parent === null)
	},
	
	fail: function(msg){
		throw new Error('Error in file ' + this.fileName + ' at line ' + this.lineNumber + ', at column ' + this.columnNumber + ':\n\t' + msg);
	},
	
	failNeedType: function(){
		this.fail('Need type here; type is not infered nor stated explicitly.');
	},
	// assuming this unit is type unit, checks that this is not empty and emits error otherwise
	checkNonEmptyType: function(){ this.isEmpty() && this.failNeedType() },
	
	// to be overriden
	
	// most of the units are really non-empty by default
	// but there are special pseudo-units, like 'empty' or 'sequence', that could be empty
	isEmpty: function(){ return false; },
	or: function(v){ return this.isEmpty()? v: this },
	
	// to-string conversions
	toTokenString: function(){ return this.getName() },
	toTranslatedCode: function(){ return '' },
	
	// for expressions only
	// there are, for example, function param declaration that have no return type (as long as they are part of bigger expression, that is function declaration)
	getResultType: function(){ return null },
	
	// in-place transformation
	// expected unwrapping of one-element sequences, elimination of strafe pure expressions (maybe with warning) etc
	simplify: function(){ this.simplifyChildren() },
	// in-place transformation
	// expected filling of fields where type is expected but they are empty at moment of call
	inferTypes: function(){ this.inferChildTypes(); },
}

// unit that can be represented just as grouper of other unit
// its still expected from this unit to have some logic of translated code formation
var SimpleUnit = function(){}
SimpleUnit.prototype = new Unit();
SimpleUnit.define = (name, inputNames, proto) => {
	proto = proto || {};
	
	var constr = function(/* vararg */){
		var args = arguments
		inputNames.forEach((name, index) => {
			var child = args[index];
			this[name] = child;
			if(child && typeof(child) === 'object' && child instanceof Unit){
				this.addChild(child);
			}
		});
	}

	if(!('toTokenString' in proto)){
		proto.toTokenString = function(){
			var result = this.getName();
			
			if(inputNames.length > 0){
				result += '('
				
				result += inputNames.map(name => {
					var part = this[name];
					
					if(!part 
						|| typeof(part) !== 'object'
						|| !('toTokenString' in part)){
						return part + ''
					}
					
					return part.toTokenString();
				}).join(', ');
				
				result += ')'
			}
			
			return result;
		}
	}

	var result = Unit.define(name, constr, proto);
	
	return result;
}

var Literal = function(){}
Literal.prototype = new SimpleUnit();
Literal.define = (name, proto) => {
	proto = proto || {};
	
	var unit = SimpleUnit.define(name, ['value'], proto);
	
	if(!('toTranslatedCode' in proto)){
		unit.prototype.toTranslatedCode = function(){ return value };
	}
	
	return unit;
}


// empty pseudo-token
// used in place it COULD be, but not present
// (and that's okay)
Unit.define('empty', function(){}, {
	isEmpty: function(){ return true },
	toTranslatedCode: function(){ this.fail('"empty" unit is impossible to translate.'); }
});

// sequence of units
Unit.define('sequence', function(codeSeparator){ this.codeSep = codeSeparator || '\n' }, {
	
	toTokenString: function(){
		return 'sequence(' + this.eachChild(c => c.toTokenString()).join(', ') + ')'
	},
	
	toTranslatedCode: function(ident){
		return this.eachChild(c => c.toTranslatedCode(ident)).join(this.codeSep);
	},
	
	isEmpty: function(){ return !this.haveChildren() }
});

// name is identifier
SimpleUnit.define('name', ['valueStr'], {
	toTranslatedCode: function(ident){ return this.valueStr }
});
SimpleUnit.define('func_def', ['argToken', 'resultTypeToken', 'bodyToken'], {
	toTranslatedCode: function(i){
		// it really should not be, as long as C have no simple way to inline-declare a function
		// it should be described somewhere else and then just referenced
		// and action of decription lies above this method's state of authority
		this.fail('This unit should not be translated directly.');
	}
})
SimpleUnit.define('func_def_arg', ['nameToken', 'typeToken'], {
	toTranslatedCode: function(){
		this.typeToken.checkNonEmptyType();
		return this.typeToken.toTranslatedCode() + ' ' + this.nameToken.toTranslatedCode();
	}
})
SimpleUnit.define('type', ['typeObject'], {
	toTranslatedCode: function(i){ return this.typeObject.toTranslatedCode() }
})

// TODO: modifiers (mutability, visibility)
SimpleUnit.define('var_decl', ['nameToken', 'typeToken', 'valueToken', 'flags'], {

	toTranslatedCode: function(i){
		this.flags.immutable && this.valueToken.isEmpty() && this.fail('Immutable variable must have initial value.');
		this.typeToken.checkNonEmptyType();
		
		if(this.typeToken.typeObject instanceof Type.Function){
			if(this.isTopLevel() && this.flags.immutable){
				var callResultType = this.typeToken.typeObject.getCallResultType(),
					args = this.valueToken.argToken
						.extractChildren(c => c instanceof units.func_def_arg)
						.map(arg => arg.toTranslatedCode())
						.join(', '),
					name = this.nameToken.toTranslatedCode(),
					body = this.valueToken.bodyTokey.toTranslatedCode(i + '\t', '\n', '\n' + i);
				
				return i + callResultType + ' ' + name + '(' + args + '){' + body + '}'
			} else {
				// FIXME: closures, class methods, mutable functions
				this.fail('Not implemented.');
			}
		} else {
			var mods = this.flags.immutable? 'const ': '',
				type = this.typeToken.toTranslatedCode(),
				name = this.nameToken.toTranslatedCode();
			return mods + type + ' ' + name + (this.valueToken.isEmpty()?'': ' = ' + this.valueToken.toTranslatedCode()) + ';';
		}
	}

});
Literal.define('double_literal');
Literal.define('integer_literal');
Literal.define('boolean_literal');
Literal.define('string_literal');

Unit.define('binary_arithmetic_expression', function(values, operators){
	this.values = values;
	this.operators = operators;
	if(values.length )
}, {
	toTokenString: function(){
		for()
	}
})

typeof(module) !== 'undefined' && (module.exports = units);
